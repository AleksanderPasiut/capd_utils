///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Author: Aleksander M. Pasiut
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <list>

namespace CapdUtils
{

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//! @brief Utility to represent list of indices
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template<typename IdxT>
class IdxList : public std::list<IdxT>
{
public:
    using std::list<IdxT>::list;

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //! Create list of indices of form (offset, offset+1, ..., offset+size-1)
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static IdxList<IdxT> create(IdxT offset, size_t size)
    {
        IdxList<IdxT> ret;
        while( ret.size() < size )
        {
            ret.push_back( offset++ );
        }
        return ret;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //! Create list of indices of form:
    //! (fill, fill, ... fill, offset, offset+1, ..., offset+size-1, fill, ... )
    //! where total_size specifies total size of generated list and pos specifies
    //! number of prepended 'fill' values.
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    static IdxList<IdxT> create(size_t total_size, size_t pos, size_t size, IdxT offset = 0, IdxT fill = -1)
    {
        IdxList<IdxT> ret;

        while (ret.size() < pos)
        {
            ret.push_back(fill);
        }

        while( ret.size() < pos + size )
        {
            ret.push_back( offset++ );
        }

        while (ret.size() < total_size)
        {
            ret.push_back(fill);
        }

        return ret;
    }
};

}
